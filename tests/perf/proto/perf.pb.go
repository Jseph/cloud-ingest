// Code generated by protoc-gen-go. DO NOT EDIT.
// source: perf.proto

/*
Package pb_perf is a generated protocol buffer package.

It is generated from these files:
	perf.proto

It has these top-level messages:
	UniformDistribution
	Directory
	FileSystem
	DataGeneratorConfig
*/
package pb_perf

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UniformDistribution struct {
	Min int32 `protobuf:"varint,1,opt,name=min" json:"min,omitempty"`
	Max int32 `protobuf:"varint,2,opt,name=max" json:"max,omitempty"`
}

func (m *UniformDistribution) Reset()                    { *m = UniformDistribution{} }
func (m *UniformDistribution) String() string            { return proto.CompactTextString(m) }
func (*UniformDistribution) ProtoMessage()               {}
func (*UniformDistribution) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UniformDistribution) GetMin() int32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *UniformDistribution) GetMax() int32 {
	if m != nil {
		return m.Max
	}
	return 0
}

type Directory struct {
	// Filesystem directory path.
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// Total number of files to be generated in that directory.
	TotalNumberFiles int32 `protobuf:"varint,2,opt,name=totalNumberFiles" json:"totalNumberFiles,omitempty"`
	// Nested directories inside that directory. Note that subDir paths will be
	// relative to the parent directory.
	SubDir []*Directory `protobuf:"bytes,4,rep,name=subDir" json:"subDir,omitempty"`
}

func (m *Directory) Reset()                    { *m = Directory{} }
func (m *Directory) String() string            { return proto.CompactTextString(m) }
func (*Directory) ProtoMessage()               {}
func (*Directory) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Directory) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Directory) GetTotalNumberFiles() int32 {
	if m != nil {
		return m.TotalNumberFiles
	}
	return 0
}

func (m *Directory) GetSubDir() []*Directory {
	if m != nil {
		return m.SubDir
	}
	return nil
}

type FileSystem struct {
	// The file system directory.
	Dir *Directory `protobuf:"bytes,1,opt,name=dir" json:"dir,omitempty"`
	// The file sizes random distribution.
	//
	// Types that are valid to be assigned to FileSizeDistribution:
	//	*FileSystem_UniformDistribution
	FileSizeDistribution isFileSystem_FileSizeDistribution `protobuf_oneof:"fileSizeDistribution"`
	// Max number of files and/or directories in filesystem directories. If the
	// total number of files/directories in a dir >= maxNodes, the tool will build
	// a directory tree to meet both number of files/directories and maxNodesInDir
	// constraints.
	MaxNodesInDir int32 `protobuf:"varint,3,opt,name=maxNodesInDir" json:"maxNodesInDir,omitempty"`
}

func (m *FileSystem) Reset()                    { *m = FileSystem{} }
func (m *FileSystem) String() string            { return proto.CompactTextString(m) }
func (*FileSystem) ProtoMessage()               {}
func (*FileSystem) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isFileSystem_FileSizeDistribution interface {
	isFileSystem_FileSizeDistribution()
}

type FileSystem_UniformDistribution struct {
	UniformDistribution *UniformDistribution `protobuf:"bytes,2,opt,name=uniformDistribution,oneof"`
}

func (*FileSystem_UniformDistribution) isFileSystem_FileSizeDistribution() {}

func (m *FileSystem) GetFileSizeDistribution() isFileSystem_FileSizeDistribution {
	if m != nil {
		return m.FileSizeDistribution
	}
	return nil
}

func (m *FileSystem) GetDir() *Directory {
	if m != nil {
		return m.Dir
	}
	return nil
}

func (m *FileSystem) GetUniformDistribution() *UniformDistribution {
	if x, ok := m.GetFileSizeDistribution().(*FileSystem_UniformDistribution); ok {
		return x.UniformDistribution
	}
	return nil
}

func (m *FileSystem) GetMaxNodesInDir() int32 {
	if m != nil {
		return m.MaxNodesInDir
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FileSystem) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FileSystem_OneofMarshaler, _FileSystem_OneofUnmarshaler, _FileSystem_OneofSizer, []interface{}{
		(*FileSystem_UniformDistribution)(nil),
	}
}

func _FileSystem_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FileSystem)
	// fileSizeDistribution
	switch x := m.FileSizeDistribution.(type) {
	case *FileSystem_UniformDistribution:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UniformDistribution); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FileSystem.FileSizeDistribution has unexpected type %T", x)
	}
	return nil
}

func _FileSystem_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FileSystem)
	switch tag {
	case 2: // fileSizeDistribution.uniformDistribution
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UniformDistribution)
		err := b.DecodeMessage(msg)
		m.FileSizeDistribution = &FileSystem_UniformDistribution{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FileSystem_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FileSystem)
	// fileSizeDistribution
	switch x := m.FileSizeDistribution.(type) {
	case *FileSystem_UniformDistribution:
		s := proto.Size(x.UniformDistribution)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DataGeneratorConfig struct {
	// Types that are valid to be assigned to DataSource:
	//	*DataGeneratorConfig_FileSystem
	DataSource isDataGeneratorConfig_DataSource `protobuf_oneof:"dataSource"`
}

func (m *DataGeneratorConfig) Reset()                    { *m = DataGeneratorConfig{} }
func (m *DataGeneratorConfig) String() string            { return proto.CompactTextString(m) }
func (*DataGeneratorConfig) ProtoMessage()               {}
func (*DataGeneratorConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isDataGeneratorConfig_DataSource interface {
	isDataGeneratorConfig_DataSource()
}

type DataGeneratorConfig_FileSystem struct {
	FileSystem *FileSystem `protobuf:"bytes,1,opt,name=fileSystem,oneof"`
}

func (*DataGeneratorConfig_FileSystem) isDataGeneratorConfig_DataSource() {}

func (m *DataGeneratorConfig) GetDataSource() isDataGeneratorConfig_DataSource {
	if m != nil {
		return m.DataSource
	}
	return nil
}

func (m *DataGeneratorConfig) GetFileSystem() *FileSystem {
	if x, ok := m.GetDataSource().(*DataGeneratorConfig_FileSystem); ok {
		return x.FileSystem
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DataGeneratorConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DataGeneratorConfig_OneofMarshaler, _DataGeneratorConfig_OneofUnmarshaler, _DataGeneratorConfig_OneofSizer, []interface{}{
		(*DataGeneratorConfig_FileSystem)(nil),
	}
}

func _DataGeneratorConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DataGeneratorConfig)
	// dataSource
	switch x := m.DataSource.(type) {
	case *DataGeneratorConfig_FileSystem:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.FileSystem); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DataGeneratorConfig.DataSource has unexpected type %T", x)
	}
	return nil
}

func _DataGeneratorConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DataGeneratorConfig)
	switch tag {
	case 1: // dataSource.fileSystem
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FileSystem)
		err := b.DecodeMessage(msg)
		m.DataSource = &DataGeneratorConfig_FileSystem{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DataGeneratorConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DataGeneratorConfig)
	// dataSource
	switch x := m.DataSource.(type) {
	case *DataGeneratorConfig_FileSystem:
		s := proto.Size(x.FileSystem)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*UniformDistribution)(nil), "pb_perf.UniformDistribution")
	proto.RegisterType((*Directory)(nil), "pb_perf.Directory")
	proto.RegisterType((*FileSystem)(nil), "pb_perf.FileSystem")
	proto.RegisterType((*DataGeneratorConfig)(nil), "pb_perf.DataGeneratorConfig")
}

func init() { proto.RegisterFile("perf.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 299 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x91, 0xc1, 0x4b, 0xc3, 0x30,
	0x14, 0xc6, 0x57, 0x3b, 0x27, 0x7b, 0x53, 0x18, 0xa9, 0x48, 0x0f, 0x1e, 0x46, 0xd9, 0x61, 0xec,
	0xd0, 0xc3, 0xc4, 0x83, 0xd7, 0x59, 0x74, 0x5e, 0x86, 0x74, 0x78, 0xf1, 0x22, 0xe9, 0x9a, 0x6a,
	0x60, 0x4d, 0xca, 0xeb, 0x2b, 0x76, 0xfe, 0x79, 0xfe, 0x65, 0x92, 0x50, 0xea, 0xc6, 0x7a, 0x7b,
	0xf9, 0xf2, 0x7e, 0x7c, 0xdf, 0x97, 0x00, 0x14, 0x02, 0xb3, 0xb0, 0x40, 0x4d, 0x9a, 0x5d, 0x14,
	0xc9, 0x87, 0x39, 0x06, 0x0f, 0xe0, 0xbd, 0x29, 0x99, 0x69, 0xcc, 0x23, 0x59, 0x12, 0xca, 0xa4,
	0x22, 0xa9, 0x15, 0x1b, 0x83, 0x9b, 0x4b, 0xe5, 0x3b, 0x13, 0x67, 0x76, 0x1e, 0x9b, 0xd1, 0x2a,
	0xbc, 0xf6, 0xcf, 0x1a, 0x85, 0xd7, 0xc1, 0x37, 0x0c, 0x23, 0x89, 0x62, 0x4b, 0x1a, 0xf7, 0x8c,
	0x41, 0xbf, 0xe0, 0xf4, 0x65, 0x89, 0x61, 0x6c, 0x67, 0x36, 0x87, 0x31, 0x69, 0xe2, 0xbb, 0x75,
	0x95, 0x27, 0x02, 0x9f, 0xe4, 0x4e, 0x94, 0x0d, 0x7f, 0xa2, 0xb3, 0x39, 0x0c, 0xca, 0x2a, 0x89,
	0x24, 0xfa, 0xfd, 0x89, 0x3b, 0x1b, 0x2d, 0x58, 0xd8, 0x24, 0x0c, 0x5b, 0x8f, 0xb8, 0xd9, 0x08,
	0x7e, 0x1d, 0x00, 0x43, 0x6d, 0xf6, 0x25, 0x89, 0x9c, 0x4d, 0xc1, 0x4d, 0x25, 0x5a, 0xe7, 0x6e,
	0xce, 0x5c, 0xb3, 0x57, 0xf0, 0xaa, 0xd3, 0xa2, 0x36, 0xcf, 0x68, 0x71, 0xdb, 0x52, 0x1d, 0x8f,
	0xb1, 0xea, 0xc5, 0x5d, 0x28, 0x9b, 0xc2, 0x55, 0xce, 0xeb, 0xb5, 0x4e, 0x45, 0xf9, 0xa2, 0x4c,
	0x72, 0xd7, 0x76, 0x3b, 0x16, 0x97, 0x37, 0x70, 0x9d, 0x99, 0xac, 0xf2, 0x47, 0x1c, 0xd2, 0xc1,
	0x3b, 0x78, 0x11, 0x27, 0xfe, 0x2c, 0x94, 0x40, 0x4e, 0x1a, 0x1f, 0xb5, 0xca, 0xe4, 0x27, 0xbb,
	0x07, 0xc8, 0xda, 0x6a, 0x4d, 0x27, 0xaf, 0x4d, 0xf7, 0xdf, 0x7a, 0xd5, 0x8b, 0x0f, 0x16, 0x97,
	0x97, 0x00, 0x29, 0x27, 0xbe, 0xd1, 0x15, 0x6e, 0x45, 0x32, 0xb0, 0x9f, 0x7c, 0xf7, 0x17, 0x00,
	0x00, 0xff, 0xff, 0xdd, 0x07, 0x5d, 0xd4, 0xf2, 0x01, 0x00, 0x00,
}
